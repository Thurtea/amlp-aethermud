// /cmds/cat.lpc
// Display file contents

// /cmds/cat.lpc
// View file contents (read-only)

int main(string args) {
    object player;
    string filepath, content;
    int privilege, fsize;

    player = this_player();
    if (!player) return 0;

    privilege = player->query_privilege();
    if (privilege < 1) {
        write("Error: Insufficient privileges. Wizard access required.\n");
        return 1;
    }

    if (!args || args == "") {
        write("Usage: cat <filename>\n");
        write("Example: cat /std/player.lpc\n");
        write("         cat player  (auto-adds .lpc and searches /std/)\n");
        return 1;
    }

    filepath = args;

    /* If no slash present, assume /std/ */
    if (strsrch(filepath, "/") == -1) {
        if (filepath[0..0] != '/') filepath = "/std/" + filepath;
    }

    /* Auto-append .lpc if no extension present */
    if (strlen(filepath) < 4 || filepath[strlen(filepath)-4..strlen(filepath)-1] != ".lpc") {
        filepath = filepath + ".lpc";
    }

    fsize = file_size(filepath);
    if (fsize < 0) {
        if (fsize == -2) {
            write("Error: '" + args + "' is a directory, not a file.\n");
        } else {
            write("Cannot open file: " + args + "\n");
            write("Tried path: " + filepath + "\n");
        }
        return 1;
    }

    content = read_file(filepath);
    if (!content || content == "") {
        write("Error: Could not read file or file is empty.\n");
        return 1;
    }

    write("File: " + filepath + "\n");
    write("Size: " + fsize + " bytes\n");
    write("----------------------------------------\n");

    string *lines = explode(content, "\n");
    int line_num = 1;
    foreach (string line in lines) {
        write(sprintf("%4d | %s\n", line_num, line));
        line_num++;
    }

    write("----------------------------------------\n");
    write((line_num - 1) + " lines total\n");
    return 1;
}

// Trim whitespace from string
private string trim(string str) {
    int start, end;
    if (!str) return "";
    start = 0;
    end = strlen(str) - 1;
    while (start <= end && (str[start] == ' ' || str[start] == '\t')) start++;
    while (end >= start && (str[end] == ' ' || str[end] == '\t')) end--;
    return (start > end) ? "" : str[start..end];
}

// Normalize path (add /lib prefix if relative)
private string normalize_path(string path, string cwd) {
    if (path[0] == '/') return path;
    if (cwd && cwd != "") return cwd + "/" + path;
    return "/lib/" + path;
}
