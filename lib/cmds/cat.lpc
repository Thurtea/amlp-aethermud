// /cmds/cat.lpc
// Display file contents

// /cmds/cat.lpc
// View file contents (read-only)

int main(string args) {
    object player = this_player();
    string resolved, *lines;
    int i;

    if (!player) return 0;
    if (!args || args == "") {
        write("Usage: cat <file>\n");
        return 1;
    }

    /* Use the player's path resolution helper (common in DS/FluffOS libs) */
    if (function_exists("resolve_path", player)) {
        resolved = (string)player->resolve_path(args);
    } else {
        /* Fallback: accept the argument as-is */
        resolved = args;
    }

    /* Auto-add .lpc if not present */
    if (strlen(resolved) < 4 || resolved[strlen(resolved)-4..] != ".lpc") {
        resolved += ".lpc";
    }

    /* Try to read the file */
    if (file_size(resolved) == -1) {
        write("File not found: " + args + "\n");
        return 1;
    }

    lines = explode(read_file(resolved), "\n");
    if (!lines || sizeof(lines) == 0) {
        write("File is empty: " + resolved + "\n");
        return 1;
    }

    write("┌─ " + resolved + "\n");
    for (i = 0; i < sizeof(lines); i++) {
        write(sprintf("%4d: %s\n", i + 1, lines[i]));
    }
    write("└─ " + sprintf("%d lines\n", sizeof(lines)));
    return 1;
}

// Trim whitespace from string
private string trim(string str) {
    int start, end;
    if (!str) return "";
    start = 0;
    end = strlen(str) - 1;
    while (start <= end && (str[start] == ' ' || str[start] == '\t')) start++;
    while (end >= start && (str[end] == ' ' || str[end] == '\t')) end--;
    return (start > end) ? "" : str[start..end];
}

// Normalize path (add /lib prefix if relative)
private string normalize_path(string path, string cwd) {
    if (path[0] == '/') return path;
    if (cwd && cwd != "") return cwd + "/" + path;
    return "/lib/" + path;
}
