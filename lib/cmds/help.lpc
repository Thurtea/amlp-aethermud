// /cmds/help.lpc
// Dynamic help system - serves .txt files, command/spell/psionic/skill/OCC/race
// query_help() fallbacks.
//
// CHANGE 1: 'help' with no args (or "topics"/"list"/"index") scans ALL .txt
//           files recursively and lists them alphabetically in 6-column format.
// CHANGE 2: 'help <cmd>' falls back to load_object(cmds/...) + query_help()
// CHANGE 3: 'help <spell>' scans lib/spells/ recursively
// CHANGE 4: 'help <psionic>' scans lib/psionics/ recursively
// CHANGE 5: 'help <skill>' scans lib/skills/ recursively
// CHANGE 6: 'help <occ>' checks lib/help/occs/ then lib/occs/<occ>.lpc
// CHANGE 7: 'help <race>' checks lib/help/races/ then lib/races/<race>.lpc

// -------------------------------------------------------------------------
// Helpers
// -------------------------------------------------------------------------

// Collect all .txt basenames from a directory (non-recursive, flat list).
// Returns a sorted string array with .txt stripped.
string *collect_txt(string dir) {
    string *files = get_dir(dir + "*.txt");
    string *result = ({});
    if (files) {
        foreach (string f in files) {
            if (strlen(f) > 4)
                result += ({ f[0..(strlen(f) - 5)] });
        }
    }
    return sort_array(result, 1);
}

// Collect .txt files from a directory AND its immediate subdirectories.
// Returns sorted, deduplicated array.
string *collect_txt_recursive(string base) {
    string *result = ({});
    // Flat files in base
    string *flat = get_dir(base + "*.txt");
    if (flat) {
        foreach (string f in flat) {
            if (strlen(f) > 4) result += ({ f[0..(strlen(f) - 5)] });
        }
    }
    // Subdirectories
    string *subdirs = get_dir(base + "*");
    if (subdirs) {
        foreach (string sub in subdirs) {
            string subpath = base + sub + "/";
            string *subfiles = get_dir(subpath + "*.txt");
            if (subfiles) {
                foreach (string f in subfiles) {
                    if (strlen(f) > 4) result += ({ f[0..(strlen(f) - 5)] });
                }
            }
        }
    }
    return sort_array(result, 1);
}

// Deduplicate a sorted string array.
string *dedup(string *arr) {
    string *out = ({});
    string prev = "";
    foreach (string s in arr) {
        if (lower_case(s) != lower_case(prev)) { out += ({ s }); prev = s; }
    }
    return out;
}

// Display topics array in N-column format (width = col_width * per_row).
void write_columns(string *topics, int per_row, int col_width) {
    int count = sizeof(topics);
    for (int i = 0; i < count; i++) {
        string t = topics[i];
        // Pad/truncate to col_width
        while (strlen(t) < col_width) t += " ";
        write("  " + t[0..(col_width - 1)]);
        if ((i + 1) % per_row == 0 || i == count - 1) write("\n");
    }
}

// Try to load an LPC file and call query_help() on it.
// Returns the help string or "" if not found.
string try_lpc_help(string lpc_path) {
    object obj;
    catch { obj = load_object(lpc_path); };
    if (!obj) return "";
    if (!function_exists("query_help", obj)) return "";
    string h = obj->query_help();
    return h ? h : "";
}

// Build spelling variants of a topic (exact, underscore, dash).
string *topic_variants(string topic) {
    string *v = ({ topic });
    string u = replace_string(replace_string(topic, "-", "_"), " ", "_");
    string d = replace_string(replace_string(topic, "_", "-"), " ", "-");
    if (u != topic) v += ({ u });
    if (d != topic && d != u) v += ({ d });
    return v;
}

// Search a list of LPC directories for topic.lpc and call query_help().
// Returns help text or "".
string search_lpc_dirs(string *dirs, string topic) {
    string *vars = topic_variants(topic);
    foreach (string dir in dirs) {
        foreach (string v in vars) {
            string h = try_lpc_help(dir + v);
            if (h && h != "") return h;
        }
    }
    return "";
}

// Recursive .lpc search: checks dir/*.lpc and dir/**/*.lpc for topic.
// Returns help text or "".
string search_lpc_tree(string base, string topic) {
    string *vars = topic_variants(topic);
    // Flat
    foreach (string v in vars) {
        string h = try_lpc_help(base + v);
        if (h && h != "") return h;
    }
    // One level of subdirs
    string *subdirs = get_dir(base + "*");
    if (subdirs) {
        foreach (string sub in subdirs) {
            foreach (string v in vars) {
                string h = try_lpc_help(base + sub + "/" + v);
                if (h && h != "") return h;
            }
        }
    }
    return "";
}

// -------------------------------------------------------------------------
// Main entry point
// -------------------------------------------------------------------------

int main(string args) {
    object player = this_player();
    if (!player) { write("Error: No player context.\n"); return 1; }
    int priv_level = player->query_privilege_level();

    if (!args || args == "") return show_all_topics(priv_level);
    args = lower_case(args);
    if (args == "topics" || args == "index" || args == "list")
        return show_all_topics(priv_level);
    return show_topic(args, priv_level);
}

// -------------------------------------------------------------------------
// CHANGE 1 â€” Show all topics (dynamic index)
// -------------------------------------------------------------------------

int show_all_topics(int priv_level) {
    string *all = ({});

    // Collect from lib/help/ and all subdirs
    string *help_subdirs = ({ "", "basics/", "systems/", "occs/", "social/",
                               "meta/" });
    if (priv_level >= 1) help_subdirs += ({ "wizard/" });
    foreach (string sub in help_subdirs) {
        string *t = collect_txt("/help/" + sub);
        if (t) all += t;
    }

    // Collect from lib/data/help/ and subdirs
    string *data_subdirs = ({ "", "commands/", "concepts/", "systems/",
                               "wizard/" });
    foreach (string sub in data_subdirs) {
        string *t = collect_txt("/data/help/" + sub);
        if (t) all += t;
    }

    all = dedup(sort_array(all, 1));

    write("\033[1mAetherMUD Help System - All Topics\033[0m\n");
    write("============================================================\n");
    if (!all || !sizeof(all)) {
        write("  (no topics found)\n");
    } else {
        write_columns(all, 6, 13);
    }
    write("\nType 'help <topic>' to read any topic.\n");
    return 1;
}

// -------------------------------------------------------------------------
// Topic lookup with LPC fallbacks (CHANGES 2-7)
// -------------------------------------------------------------------------

int show_topic(string topic, int priv_level) {
    // Build variants
    string *vars = topic_variants(topic);

    // --- .txt search ---
    string *search_dirs = ({
        "/help/",      "/help/basics/",  "/help/systems/",
        "/help/occs/", "/help/social/",  "/help/meta/",
        "/data/help/", "/data/help/commands/", "/data/help/concepts/",
        "/data/help/systems/",
    });
    if (priv_level >= 1) search_dirs += ({ "/help/wizard/", "/data/help/wizard/" });

    foreach (string dir in search_dirs) {
        foreach (string v in vars) {
            string content = read_file(dir + v + ".txt");
            if (content && content != "") {
                write("\033[1m--- Help: " + topic + " ---\033[0m\n\n");
                write(content);
                write("\n");
                return 1;
            }
        }
    }

    // --- CHANGE 2: Command fallback ---
    {
        string *cmd_dirs = ({ "cmds/", "cmds/admin/", "cmds/wizard/",
                               "cmds/creator/" });
        string h = search_lpc_dirs(cmd_dirs, topic);
        if (h && h != "") {
            write("\033[1m--- Help: " + topic + " ---\033[0m\n\n");
            write(h); write("\n"); return 1;
        }
    }

    // --- CHANGE 3: Spell fallback ---
    {
        string h = search_lpc_tree("spells/", topic);
        if (h && h != "") {
            write("\033[1m--- Help: " + topic + " (spell) ---\033[0m\n\n");
            write(h); write("\n"); return 1;
        }
    }

    // --- CHANGE 4: Psionic fallback ---
    {
        string h = search_lpc_tree("psionics/", topic);
        if (h && h != "") {
            write("\033[1m--- Help: " + topic + " (psionic) ---\033[0m\n\n");
            write(h); write("\n"); return 1;
        }
    }

    // --- CHANGE 5: Skill fallback ---
    {
        string h = search_lpc_tree("skills/", topic);
        if (h && h != "") {
            write("\033[1m--- Help: " + topic + " (skill) ---\033[0m\n\n");
            write(h); write("\n"); return 1;
        }
    }

    // --- CHANGE 6: OCC fallback ---
    {
        string *occ_dirs = ({ "occs/" });
        string h = search_lpc_dirs(occ_dirs, topic);
        if (h && h != "") {
            write("\033[1m--- Help: " + topic + " (OCC) ---\033[0m\n\n");
            write(h); write("\n"); return 1;
        }
    }

    // --- CHANGE 7: Race fallback ---
    {
        string *race_dirs = ({ "races/" });
        string h = search_lpc_dirs(race_dirs, topic);
        if (h && h != "") {
            write("\033[1m--- Help: " + topic + " (race) ---\033[0m\n\n");
            write(h); write("\n"); return 1;
        }
    }

    // Not found
    write("No help found for: " + topic + "\n");
    write("Type 'help' to see all available topics.\n");
    return 1;
}

string query_help() {
    return
"HELP - Topic-based help system\n\n"
"Usage:\n"
"  help                  List all available topics (alphabetical)\n"
"  help <topic>          Read a specific help topic\n"
"  help topics           Same as 'help' (full topic list)\n"
"  help <category>       List topics in a category\n\n"
"Categories: basics, systems, occs, social, meta\n"
"Wizard categories: wizard (requires wizard access)\n\n"
"The help system searches:\n"
"  1. Help text files   (lib/help/ and lib/data/help/)\n"
"  2. Commands          (lib/cmds/) via query_help()\n"
"  3. Spells            (lib/spells/) via query_help()\n"
"  4. Psionics          (lib/psionics/) via query_help()\n"
"  5. Skills            (lib/skills/) via query_help()\n"
"  6. OCCs              (lib/occs/) via query_help()\n"
"  7. Races             (lib/races/) via query_help()\n";
}
