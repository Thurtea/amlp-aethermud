// /lib/daemon/command.c
// Command Daemon - Routes and executes all player commands

#include <globals.h>

inherit DAEMON;

// Global command registry
private mapping commands;
private mapping aliases;
private string *command_paths;

void create() {
    ::create();
    
    commands = ([]);
    aliases = ([]);
    
    // Define command search paths (in priority order)
    command_paths = ({
        "/cmds/",
        "/cmds/admin/",
        "/cmds/wizard/",
        "/cmds/creator/",
    });
    
    // Initialize command registry
    init_commands();
}

void init_commands() {
    commands["north"] = "cmds/go";
    commands["south"] = "cmds/go";
    commands["east"] = "cmds/go";
    commands["west"] = "cmds/go";
    commands["up"] = "cmds/go";
    commands["down"] = "cmds/go";
    commands["n"] = "cmds/go";
    commands["s"] = "cmds/go";
    commands["e"] = "cmds/go";
    commands["w"] = "cmds/go";
    commands["u"] = "cmds/go";
    commands["d"] = "cmds/go";
    // Communication
    commands["say"] = "cmds/say";
    commands["'"] = "cmds/say";
    commands["tell"] = "cmds/tell";
    commands["shout"] = "cmds/shout";
    commands["chat"] = "cmds/chat";
    commands["whisper"] = "cmds/whisper";
    // Intermud / external chat channel (stub removed; true Intermud needs I3 daemon)
    commands["emote"] = "cmds/emote";
    commands[":"] = "cmds/emote";
    // Information
    commands["look"] = "cmds/look";
    commands["l"] = "cmds/look";
    commands["examine"] = "cmds/examine";
    commands["exits"] = "cmds/exits";
    commands["inventory"] = "cmds/inventory";
    commands["i"] = "cmds/inventory";
    commands["equipment"] = "cmds/equipment";
    commands["eq"] = "cmds/equipment";
    commands["stats"] = "cmds/stats";
    commands["score"] = "cmds/score";
    commands["who"] = "cmds/who";
    commands["help"] = "cmds/help";
    commands["ls"] = "cmds/ls";
    // Actions
    commands["take"] = "cmds/take";
    commands["put"] = "cmds/put";
    commands["get"] = "cmds/take";  // Alias for take
    commands["drop"] = "cmds/drop";  // use dedicated drop command
    commands["give"] = "cmds/give";
    // Equipment
    commands["wear"] = "cmds/wear";
    commands["wield"] = "cmds/wield";
    commands["remove"] = "cmds/remove";
    commands["unwield"] = "cmds/unwield";
    commands["repair"] = "cmds/repair";  // Phase 3, Step 4
    // Character development
    commands["skills"] = "cmds/skills";
    commands["languages"] = "cmds/languages";
    commands["cast"] = "cmds/cast";
    commands["surname"] = "cmds/surname";  // Phase 5, Step 4
    commands["sirname"] = "cmds/sirname";
    commands["pskills"] = "cmds/pskills";
    commands["sskills"] = "cmds/sskills";
    commands["description"] = "cmds/description";
    commands["selectocc"] = "cmds/selectocc";
    commands["hatch"] = "cmds/hatch";       // Falconry: hatch a hawk egg
    // Social/introduction
    commands["introduce"] = "cmds/introduce";
    commands["greet"] = "cmds/introduce";  // Alias for introduce
    commands["remember"] = "cmds/remember";
    commands["position"] = "cmds/position";  // RP position
    // System
    commands["quit"] = "cmds/quit";
    commands["logout"] = "cmds/quit";
    commands["test"] = "cmds/test";
    // Admin commands (will check privilege internally)
    commands["shutdown"] = "cmds/admin/shutdown";
    commands["promote"] = "cmds/admin/promote";
    commands["demote"] = "cmds/admin/demote";
    commands["grantskill"] = "cmds/admin/grantskill";
    commands["users"] = "cmds/admin/users";
    commands["tattoogun"] = "cmds/admin/tattoogun";
    commands["reequip"]  = "cmds/admin/reequip";
    // Wizard commands (check privilege internally)
    commands["setocc"] = "cmds/wizard/setocc";
    commands["wiztool"] = "cmds/admin/wiztool";
    commands["wiz"] = "cmds/admin/wiz";
    commands["goto"] = "cmds/admin/goto";
    commands["stat"] = "cmds/admin/stat";
    commands["testskill"] = "cmds/admin/testskill";
    // QCS - Quick Creation System (domain/coding/admin roles)
    commands["create"] = "cmds/creator/create";
    commands["modify"] = "cmds/creator/modify";
    commands["deploy"] = "cmds/creator/deploy";
    // Wizard building tools (check privilege internally)
    commands["pwd"] = "cmds/wizard/pwd";
    commands["cd"] = "cmds/wizard/cd";
    commands["eval"] = "cmds/wizard/eval";
    commands["cat"] = "cmds/wizard/cat";
    commands["ed"] = "cmds/wizard/ed";
    commands["clone"] = "cmds/wizard/clone";
    commands["load"] = "cmds/wizard/load";
    commands["update"] = "cmds/wizard/update";
    commands["destruct"] = "cmds/wizard/destruct";
    commands["setrole"] = "cmds/admin/setrole";

    // Position commands
    commands["sit"]      = "cmds/sit";
    commands["stand"]    = "cmds/stand";
    commands["sleep"]    = "cmds/sleep";
    commands["wake"]     = "cmds/wake";
    // Object interaction
    commands["open"]     = "cmds/open";
    commands["close"]    = "cmds/close";
    commands["lock"]     = "cmds/lock";
    commands["unlock"]   = "cmds/unlock";
    commands["read"]     = "cmds/read";
    commands["write"]    = "cmds/write";
    // Social/group
    commands["follow"]   = "cmds/follow";
    commands["group"]    = "cmds/group";
    // Utility
    commands["time"]     = "cmds/time";
    commands["date"]     = "cmds/time";
    commands["save"]     = "cmds/save";
    commands["consider"] = "cmds/consider";
    commands["occs"] = "cmds/occs";
    // Wiz-tool commands (privilege checked internally; item required)
    commands["orb"]     = "cmds/orb";      /* Admin orb — admin only (priv>=2) */
    commands["rp"]      = "cmds/rp";       /* RP tool — wizard+ (priv>=1) */
    commands["wand"]    = "cmds/wand";     /* Admin wand — admin only (priv>=2) */
    commands["qcs"]     = "cmds/qcs";      /* QCS creator tool — wizard+ (priv>=1) */
    commands["code"]    = "cmds/code";     /* Code tool — wizard+ (priv>=1) */
    commands["crystal"] = "cmds/crystal";  /* Crystal ball — wizard+ (priv>=1) */
}

// Main command execution function
int execute_command(object player, string input, int priv_level) {
    string verb, args;
    object room, wiztool;
    int result;
    
    if (!player || !input || input == "") {
        return 0;
    }
    
    // Parse command into verb and arguments
    if (sscanf(input, "%s %s", verb, args) != 2) {
        verb = input;
        args = "";
    }
    
    verb = lower_case(verb);
    
    // Priority 1: Check wiztool (for wizards/admins)
    wiztool = player->query_wiztool();
    if (wiztool) {
        result = wiztool->process_command(verb, args);
        if (result) return 1;
    }
    
    // Priority 2: Check add_action registered commands
    if (function_exists("try_action", player)) {
        result = player->try_action(verb, args);
        if (result) return 1;
    }
    
    // Priority 3: Check player's local commands (skills, abilities)
    if (function_exists("local_command", player)) {
        result = player->local_command(verb, args);
        if (result) return 1;
    }
    
    // Priority 4: Check environment commands (room-specific)
    room = environment(player);
    if (room && function_exists("local_command", room)) {
        result = room->local_command(verb, args);
        if (result) return 1;
    }
    
    // Priority 5: Check global command registry
    if (commands[verb]) {
        return execute_global_command(player, commands[verb], verb, args, priv_level);
    }

    // Priority 6: Try to find command in search paths
    result = search_command_paths(player, verb, args, priv_level);
    if (result) return 1;

    // Command not found
    tell_object(player, "Unknown command: " + verb);
    tell_object(player, "Type 'help' for available commands.");
    return 1;
}

// Execute a registered global command
private int execute_global_command(object player, string path, string verb, string args, int priv_level) {
    object cmd;
    int result;

    // Ensure absolute path — VM requires leading slash
    string abs_path = (path[0] == '/') ? path : "/" + path;

    // Try to load the command object
    catch {
        cmd = load_object(abs_path);
    };

    if (!cmd) {
        tell_object(player, "Error: Command '" + verb + "' failed to load.");
        return 1;
    }

    // Check if command has privilege requirements
    if (function_exists("query_privilege_required", cmd)) {
        int required = cmd->query_privilege_required();
        if (priv_level < required) {
            tell_object(player, "You don't have sufficient privileges for that command.");
            return 1;
        }
    }

    // Pass caller privilege to the command if it supports it
    if (function_exists("set_caller_privilege", cmd)) {
        cmd->set_caller_privilege(priv_level);
    }

    // Execute the command
    if (function_exists("main", cmd)) {
        result = cmd->main(args);
        return result;
    }
    
    tell_object(player, "Error: Command '" + verb + "' is not properly implemented.");
    return 1;
}

// Search command paths for a matching command file
private int search_command_paths(object player, string verb, string args, int priv_level) {
    string path;
    object cmd;

    foreach (string dir in command_paths) {
        path = dir + verb;

        catch {
            string abs_path = (path[0] == '/') ? path : "/" + path;
            cmd = load_object(abs_path);
        };

        if (cmd && function_exists("main", cmd)) {
            return execute_global_command(player, path, verb, args, priv_level);
        }
    }

    return 0;
}

// Register a new command
void register_command(string verb, string path) {
    commands[verb] = path;
}

// Unregister a command
void unregister_command(string verb) {
    map_delete(commands, verb);
}

// Get list of available commands
string *query_commands() {
    return keys(commands);
}

// Get command mapping (for debugging)
mapping query_command_map() {
    return copy(commands);
}

// Return commands visible to a given player, filtered by privilege level
string *query_available_commands(object player) {
    if (!player) return sort_array(keys(commands), 1);

    int priv = 0;
    if (function_exists("query_privilege_level", player))
        priv = player->query_privilege_level();

    string role = "";
    if (function_exists("query_property", player))
        role = player->query_property("wizard_role");
    if (!role) role = "";

    string *all = keys(commands);
    string *out = ({});

    // Admins see everything
    if (priv >= 2) {
        return sort_array(all, 1);
    }

    foreach (string v in all) {
        string p = commands[v];

        // Creator/QCS commands: only domain/coding/admin wizards
        if (strsrch(p, "/cmds/creator/") == 0) {
            if (priv >= 1 && (role == "domain" || role == "coding" || role == "admin"))
                out += ({ v });
            continue;
        }

        // Admin-only commands
        if (strsrch(p, "/cmds/admin/") == 0) {
            if (role == "admin" || priv >= 2)
                out += ({ v });
            continue;
        }

        // Wizard tooling commands: only visible to wizards (priv >=1)
        if (strsrch(p, "/cmds/wizard/") == 0) {
            if (priv >= 1) out += ({ v });
            continue;
        }

        // Default: general player commands
        out += ({ v });
    }

    return sort_array(out, 1);
}
