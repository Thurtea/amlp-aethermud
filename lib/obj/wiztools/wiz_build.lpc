// /lib/obj/wiztools/wiz_build.lpc
// Domain Wizard Build Tool - Area management, room cloning, area listing
// For Domain wizards (wizard_role == "domain")

inherit "/lib/obj/wiztools/base_wiztool";

void create() {
    ::create();
    set_name("build tool");
    set_id(({ "build tool", "wiz build", "wiz_build", "domain tool" }));
    set_short("a Domain Wizard's build tool");
    set_long(
        "A brass compass that always points toward unfinished areas.\n"
        "Its needle spins when near rooms that need descriptions,\n"
        "exits, or NPCs. A true builder's companion.\n\n"
        "Commands:\n"
        "  build area       List your area files\n"
        "  build rooms      List all rooms in current domain\n"
        "  build exits      Show exits from current room\n"
        "  build clone <room_path>  Clone a room template\n"
        "  build link <dir> <room>  Link exit to another room\n"
        "  build audit      Check current room for missing data\n"
        "  build help       Show this help\n"
    );
    set_weight(1);
    set_value(0);
    set_property("no_drop", 1);
    set_property("no_steal", 1);
    set_property("wizard_tool", 1);
}

int check_wizard_level(object who) {
    if (!who) return 0;
    if (function_exists("query_privilege_level", who))
        return (int)who->query_privilege_level() >= 1;
    return 0;
}

void init() {
    if (!environment() || !interactive(environment())) return;
    if (!check_wizard_level(environment())) return;
    add_action("cmd_build", "build");
}

int cmd_build(string str) {
    object player = this_player();
    if (!check_wizard_level(player)) {
        write("The tool refuses to work for you.\n");
        return 1;
    }

    if (!str || str == "") return show_help();

    string subcmd, rest;
    if (sscanf(str, "%s %s", subcmd, rest) != 2) {
        subcmd = str;
        rest = "";
    }
    subcmd = lower_case(subcmd);

    switch (subcmd) {
        case "area":   return cmd_area(player);
        case "rooms":  return cmd_rooms(player);
        case "exits":  return cmd_exits(player);
        case "clone":  return cmd_clone_room(player, rest);
        case "link":   return cmd_link(player, rest);
        case "audit":  return cmd_audit(player);
        case "help":   return show_help();
        default:
            write("Unknown build command: " + subcmd + "\n");
            return show_help();
    }
}

int cmd_area(object player) {
    string wiz_name = "";
    if (function_exists("query_name", player))
        wiz_name = lower_case(player->query_name());

    string base = "/domains/wizard/" + wiz_name + "/area";
    string *types = ({ "room", "npc", "weapon", "armor", "item" });

    write("\n\033[1;34m=== Domain Area: " + wiz_name + " ===\033[0m\n\n");

    int total = 0;
    foreach (string type in types) {
        string dir = base + "/" + type + "/";
        string *files = get_dir(dir + "*.lpc");
        if (files && sizeof(files)) {
            write("\033[1m" + capitalize(type) + "s (" + sizeof(files) + "):\033[0m\n");
            foreach (string f in files) {
                string name;
                if (sscanf(f, "%s.lpc", name) != 1) name = f;
                write("  " + dir + name + "\n");
                total++;
            }
        }
    }

    if (total == 0) write("  (no files yet)\n");
    write("\nTotal: " + total + " files\n\n");
    return 1;
}

int cmd_rooms(object player) {
    object room = environment(player);
    if (!room) {
        write("You are not in a room.\n");
        return 1;
    }

    string room_path = file_name(room);
    // Extract domain directory
    string domain_dir;
    int last_slash = -1;
    int i;
    for (i = strlen(room_path) - 1; i >= 0; i--) {
        if (room_path[i] == '/') { last_slash = i; break; }
    }
    if (last_slash > 0) {
        domain_dir = room_path[0..last_slash];
    } else {
        domain_dir = "/domains/";
    }

    string *files = get_dir(domain_dir + "*.lpc");
    write("\n\033[1;34m=== Rooms in " + domain_dir + " ===\033[0m\n\n");
    if (files && sizeof(files)) {
        foreach (string f in files) {
            string marker = "";
            if (domain_dir + f == room_path + ".lpc" ||
                domain_dir + f == room_path) {
                marker = " \033[1;33m<-- you are here\033[0m";
            }
            write("  " + f + marker + "\n");
        }
    } else {
        write("  (no .lpc files found)\n");
    }
    write("\n");
    return 1;
}

int cmd_exits(object player) {
    object room = environment(player);
    if (!room) {
        write("You are not in a room.\n");
        return 1;
    }

    write("\n\033[1;34m=== Exits from " + (function_exists("query_short", room) ?
          room->query_short() : "here") + " ===\033[0m\n\n");

    if (function_exists("query_exits", room)) {
        mapping exits = room->query_exits();
        if (exits && sizeof(exits)) {
            foreach (string dir, string dest in exits) {
                // Check if destination exists
                string status = "\033[1;32m[OK]\033[0m";
                if (file_size(dest + ".lpc") <= 0 && file_size(dest) <= 0) {
                    status = "\033[1;31m[MISSING]\033[0m";
                }
                write("  " + dir + " -> " + dest + " " + status + "\n");
            }
        } else {
            write("  No exits defined.\n");
        }
    } else {
        write("  Room does not support query_exits().\n");
    }
    write("\n");
    return 1;
}

int cmd_clone_room(object player, string source) {
    if (!source || source == "") {
        write("Usage: build clone <source_room_path>\n");
        write("Clones a room file as a template into your workspace.\n");
        return 1;
    }

    // Read source
    string content = read_file(source + ".lpc");
    if (!content) content = read_file(source);
    if (!content) {
        write("Could not read: " + source + "\n");
        return 1;
    }

    string wiz_name = "";
    if (function_exists("query_name", player))
        wiz_name = lower_case(player->query_name());

    // Extract filename
    string basename;
    int idx;
    for (idx = strlen(source) - 1; idx >= 0; idx--) {
        if (source[idx] == '/') break;
    }
    basename = source[idx+1..];
    if (sscanf(basename, "%s.lpc", basename) != 1) {
        // basename is already clean
    }

    string dest = "/domains/wizard/" + wiz_name + "/area/room/" + basename + ".lpc";

    if (file_size(dest) > 0) {
        write("File already exists: " + dest + "\n");
        return 1;
    }

    write_file(dest, content);
    write("\033[1;32mCloned:\033[0m " + source + " -> " + dest + "\n");
    write("Edit with: modify " + basename + " show\n");
    return 1;
}

int cmd_link(object player, string rest) {
    if (!rest || rest == "") {
        write("Usage: build link <direction> <room_path>\n");
        return 1;
    }

    string dir, dest;
    if (sscanf(rest, "%s %s", dir, dest) != 2) {
        write("Usage: build link <direction> <room_path>\n");
        return 1;
    }

    object room = environment(player);
    if (!room) {
        write("You are not in a room.\n");
        return 1;
    }

    if (function_exists("add_exit", room)) {
        room->add_exit(dir, dest);
        write("\033[1;32mLinked:\033[0m " + dir + " -> " + dest + "\n");
        write("Note: This is runtime only. Edit the room file to make permanent.\n");
    } else {
        write("Room does not support add_exit().\n");
    }
    return 1;
}

int cmd_audit(object player) {
    object room = environment(player);
    if (!room) {
        write("You are not in a room.\n");
        return 1;
    }

    write("\n\033[1;34m=== Room Audit ===\033[0m\n\n");

    string room_name = file_name(room);
    write("File: " + room_name + "\n\n");

    int issues = 0;

    // Check short description
    string short_desc = "";
    if (function_exists("query_short", room))
        short_desc = room->query_short();
    if (!short_desc || short_desc == "" || short_desc == "a new room") {
        write("  \033[1;31m[!]\033[0m Short description missing or default\n");
        issues++;
    } else {
        write("  \033[1;32m[OK]\033[0m Short: " + short_desc + "\n");
    }

    // Check long description
    string long_desc = "";
    if (function_exists("query_long", room))
        long_desc = room->query_long();
    if (!long_desc || long_desc == "" || strlen(long_desc) < 20) {
        write("  \033[1;31m[!]\033[0m Long description missing or too short\n");
        issues++;
    } else {
        write("  \033[1;32m[OK]\033[0m Long description present (" + strlen(long_desc) + " chars)\n");
    }

    // Check exits
    if (function_exists("query_exits", room)) {
        mapping exits = room->query_exits();
        if (!exits || !sizeof(exits)) {
            write("  \033[1;33m[?]\033[0m No exits defined (dead-end room)\n");
            issues++;
        } else {
            write("  \033[1;32m[OK]\033[0m " + sizeof(exits) + " exit(s) defined\n");
        }
    }

    // Check light
    int light = 0;
    if (function_exists("query_property", room))
        light = (int)room->query_property("light");
    if (light <= 0) {
        write("  \033[1;33m[?]\033[0m No light property set (dark room)\n");
        issues++;
    } else {
        write("  \033[1;32m[OK]\033[0m Light level: " + light + "\n");
    }

    if (issues == 0) {
        write("\n  \033[1;32mRoom passes audit!\033[0m\n");
    } else {
        write("\n  " + issues + " issue(s) found.\n");
    }
    write("\n");
    return 1;
}

int show_help() {
    write("\n\033[1;34m=== Domain Build Tool ===\033[0m\n\n");
    write("Commands:\n");
    write("  build area        List your workspace files\n");
    write("  build rooms       List rooms in current domain dir\n");
    write("  build exits       Show exits from current room\n");
    write("  build clone <src> Clone a room into your workspace\n");
    write("  build link <d> <r> Link exit (runtime only)\n");
    write("  build audit       Check current room for issues\n");
    write("  build help        This help\n\n");
    write("For full building, also use:\n");
    write("  create/modify/deploy (QCS commands)\n");
    write("  mkroom/mkobject (traditional builders)\n\n");
    return 1;
}
