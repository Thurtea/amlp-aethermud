// Export send_ansi as an efun for LPC
// TEMP DEBUG: Pass-through efun_send_ansi for diagnostics
nomask string efun_send_ansi(string s) {
    return s;
}
// /lib/secure/master.c
// Master Object - Core LPC driver interface

#include <globals.h>

// State
private mapping loaded_daemons;

void create() {
    loaded_daemons = ([]);
    
    // Initialize the MUD
    write("Master object initializing...\n");
    
    // Step 1: Load simul_efun first (provides additional efuns)
    load_simul_efun();
    
    // Step 2: Initialize core daemons
    init_daemons();
    
    // Step 3: Set up directories
    init_directories();

    /* Test: attempt to load a small test clone to exercise compile/load/clone
     * This helps validate that clone_object/load_object and the compiler
     * + program_loader path work at runtime. Remove when no longer needed. */
    catch {
        object t = load_object("/test/clone_test");
        if (t) {
            write("[MASTER TEST] Loaded test clone: " + file_name(t) + "\n");
        } else {
            write("[MASTER TEST] Failed to load test clone.\n");
        }
    };
    
    write("Master object initialized successfully.\n");
}

// Load simulated efuns
private void load_simul_efun() {
    object simul;
    
    catch {
        simul = load_object("/secure/simul_efun");
    };
    
    if (simul) {
        write("Simul_efun loaded.\n");
    } else {
        write("WARNING: Simul_efun failed to load.\n");
    }
}

// Initialize core daemons
private void init_daemons() {
    string *daemon_list = ({
        "/daemon/command",
        "/daemon/login",
        "/daemon/chargen",
        "/daemon/skills",
        "/daemon/languages",
        "/daemon/psionics",
        "/daemon/spells",
    });
    
    foreach (string daemon in daemon_list) {
        object d;
        
        catch {
            d = load_object(daemon);
        };
        
        if (d) {
            loaded_daemons[daemon] = d;
            write("  Loaded: " + daemon + "\n");
        } else {
            write("  WARNING: Failed to load " + daemon + "\n");
        }
    }
}

// Create necessary directories
private void init_directories() {
    string *dirs = ({
        "/save",
        "/save/players",
        "/log",
    });
    
    foreach (string dir in dirs) {
        if (file_size(dir) != -2) {
            mkdir(dir);
        }
    }
}

// === DRIVER APPLIES (REQUIRED) ===

// Called when a user connects
object connect() {
    object login;
    
    catch {
        login = clone_object("/clone/login");
    };
    
    if (!login) {
        write("ERROR: Failed to clone login object!\n");
        return 0;
    }
    
    return login;
}

// Handle compilation/runtime errors
void flag_error(string err) {
    string logfile = "/log/errors.log";
    
    write("COMPILATION ERROR:\n" + err + "\n");
    
    // Log to file
    write_file(logfile, ctime(time()) + "\n" + err + "\n\n");
}

// Get root UID (for security system)
string get_root_uid() {
    return "Root";
}

// Get backbone UID
string get_bb_uid() {
    return "Backbone";
}

// Return creator of a file (for security)
string creator_file(string file) {
    string *parts;

    if (!file || file == "") return "Root";

    // Remove leading slash
    if (file[0] == '/') {
        file = file[1..];
    }

    parts = explode(file, "/");

    if (sizeof(parts) < 2) return "Root";

    // Secure directory files are owned by Root
    if (parts[0] == "secure") return "Root";

    // Domain files are owned by the domain creator
    if (parts[0] == "domains" && sizeof(parts) >= 2) {
        return parts[1];
    }

    // Player save files
    if (parts[0] == "save") return "Root";

    // Standard library files
    if (parts[0] == "std") return "Root";

    // Daemon files
    if (parts[0] == "daemon") return "Root";

    // Command files
    if (parts[0] == "cmds") return "Root";

    // Everything else
    return "Root";
}

// Validate read access
int valid_read(string file, object caller, string func) {
    if(!file) return 0;
    if(strsrch(file, "/save/players/") != -1) {
        if(objectp(caller) && function_exists("query_name", caller)) {
            string pname = lower_case((string)caller->query_name() || "");
            if(pname != "" && strsrch(lower_case(file), "/" + pname + ".o") != -1)
                return 1;
        }
        if(creator_file(file_name(caller || this_object())) == "Root") return 1;
        return 0;
    }
    if(strsrch(file, "/secure/") != -1) {
        if(creator_file(file_name(caller || this_object())) == "Root") return 1;
        return 0;
    }
    return 1;
}

// Validate write access
int valid_write(string file, object caller, string func) {
    string caller_name, fname;

    if (!caller) return 0;
    if (!function_exists("query_name", caller)) return 0;
    caller_name = (string)caller->query_name();
    if (!caller_name || caller_name == "") return 0;

    // Players can save their own files
    if (sscanf(file, "/save/players/%s.o", fname) == 1) {
        if (lower_case(fname) == lower_case(caller_name)) return 1;
    }
    if (sscanf(file, "lib/save/players/%s.o", fname) == 1) {
        if (lower_case(fname) == lower_case(caller_name)) return 1;
    }

    // Log files are writable
    if (sscanf(file, "/log/%s", fname) == 1) return 1;
    if (sscanf(file, "lib/log/%s", fname) == 1) return 1;

    return 0;
}

// === MISSING MASTER APPLIES -- appended ===

object get_master() { return this_object(); }

int valid_seteuid(object ob, string uid) {
    if(!ob || !uid) return 0;
    if(creator_file(file_name(ob)) == "Root") return 1;
    if(uid == creator_file(file_name(ob))) return 1;
    if(uid == get_bb_uid()) return 1;
    return 0;
}

string author_file(string file) { return creator_file(file); }

int valid_override(object ob, string func) {
    if(creator_file(file_name(ob)) == "Root") return 1;
    return 0;
}

int valid_exec(object ob, string prog) {
    if(creator_file(file_name(ob)) == "Root") return 1;
    return 0;
}

int valid_bind(int port, string name) {
    if(port > 1024) return 1;
    return 0;
}

int valid_apply(string func, object ob) { return 1; }

void runtime_error(string err, string prg, string curobj, int line) {
    string msg = sprintf("[RUNTIME] %s\n  in %s line %d\n  current: %s\n\n",
        err, prg || "?", line, curobj || "?");
    write(msg);
    write_file("/log/runtime_errors.log", ctime(time()) + "\n" + msg);
}

void log_error(string file, string err) {
    string msg = sprintf("[COMPILE] %s\n  in %s\n\n", err, file || "?");
    write(msg);
    write_file("/log/compile_errors.log", ctime(time()) + "\n" + msg);
}

void destruct_ob(object ob) {
    if(!mappingp(loaded_daemons) || !ob) return;
    string *ks = keys(loaded_daemons); int i;
    for(i = 0; i < sizeof(ks); i++)
        if(loaded_daemons[ks[i]] == ob) map_delete(loaded_daemons, ks[i]);
}
