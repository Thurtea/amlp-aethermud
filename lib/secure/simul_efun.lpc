// /secure/simul_efun.lpc
// Simulated efuns -- globally available to all LPC objects.

void create() {}

// ============================================================
// NOTIFY FAIL
// ============================================================
private mapping _nf = ([]);

void notify_fail(string msg) {
    if(previous_object() && msg) _nf[previous_object()] = msg;
}

string query_notify_fail(object ob) { return _nf[ob]; }
void clear_notify_fail(object ob) { map_delete(_nf, ob); }

// ============================================================
// STRING UTILITIES
// ============================================================

string strip_ansi(string str) {
    if(!stringp(str)) return "";
    string out = ""; int i = 0; int n = strlen(str);
    while(i < n) {
        if(str[i] == 27 && i+1 < n && str[i+1] == '[') {
            i += 2;
            while(i < n && str[i] != 'm') i++;
            i++;
        } else { out += str[i..i]; i++; }
    }
    return out;
}

int visible_len(string str) { return strlen(strip_ansi(str)); }

string trim(string str) {
    if(!stringp(str)) return "";
    while(strlen(str) > 0 && (str[0]==' ' || str[0]=='\t')) str = str[1..];
    while(strlen(str) > 0 && (str[<1]==' ' || str[<1]=='\t')) str = str[..<2];
    return str;
}

string capitalize(string str) {
    if(!stringp(str) || str == "") return str;
    return upper_case(str[0..0]) + str[1..];
}

string repeat_str(string s, int n) {
    string r = ""; int i;
    for(i = 0; i < n; i++) r += s;
    return r;
}

string pad_str(string s, int width) {
    int vl = visible_len(s);
    if(vl >= width) return s;
    return s + repeat_str(" ", width - vl);
}

string center_str(string s, int width) {
    int vl = visible_len(s);
    if(vl >= width) return s;
    int pad = width - vl; int left = pad / 2;
    return repeat_str(" ", left) + s + repeat_str(" ", pad - left);
}

string array_to_list(string *arr) {
    int sz;
    if(!arrayp(arr) || !(sz = sizeof(arr))) return "";
    if(sz == 1) return arr[0];
    if(sz == 2) return arr[0] + " and " + arr[1];
    return implode(arr[0..<2], ", ") + ", and " + arr[<1];
}

string add_article(string noun) {
    if(!stringp(noun) || noun == "") return noun;
    string c = lower_case(noun[0..0]);
    if(c=="a"||c=="e"||c=="i"||c=="o"||c=="u") return "an " + noun;
    return "a " + noun;
}

// ============================================================
// ANSI HELPERS
// ============================================================
private mapping _ansi = ([
    "reset":"\x1b[0m",    "bold":"\x1b[1m",
    "red":"\x1b[31m",     "green":"\x1b[32m",
    "yellow":"\x1b[33m",  "blue":"\x1b[34m",
    "magenta":"\x1b[35m", "cyan":"\x1b[36m",
    "white":"\x1b[37m",   "bred":"\x1b[91m",
    "bgreen":"\x1b[92m",  "byellow":"\x1b[93m",
    "bblue":"\x1b[94m",   "bmagenta":"\x1b[95m",
    "bcyan":"\x1b[96m",   "bwhite":"\x1b[97m",
]);

string ansi_code(string color) { return _ansi[color] || ""; }

string ansi_color(string color, string text) {
    string code = _ansi[color];
    if(!code) return text;
    return code + text + _ansi["reset"];
}

// ============================================================
// PATH UTILITIES
// ============================================================

string resolve_path(string base, string path) {
    if(!stringp(path)) return base || "/";
    if(!stringp(base)) base = "/";
    string full;
    if(path[0] == '/') { full = path; }
    else { if(base[<1] != '/') base += "/"; full = base + path; }
    string *parts = explode(full, "/"), *out = ({}); int i;
    for(i = 0; i < sizeof(parts); i++) {
        if(parts[i]=="" || parts[i]==".") continue;
        if(parts[i]=="..") { if(sizeof(out)) out = out[0..<2]; }
        else out += ({ parts[i] });
    }
    return "/" + implode(out, "/");
}

int safe_path(string path) {
    if(!stringp(path)) return 0;
    if(strsrch(path, "..") != -1) return 0;
    return 1;
}

string dirname(string path) {
    if(!stringp(path)) return "/";
    int idx = strsrch(path, "/", -1);
    if(idx <= 0) return "/";
    return path[0..idx-1];
}

string basename_path(string path) {
    if(!stringp(path)) return "";
    int idx = strsrch(path, "/", -1);
    if(idx < 0) return path;
    return path[idx+1..];
}

// ============================================================
// OBJECT UTILITIES
// ============================================================

string obj_name(object ob) {
    if(!objectp(ob)) return "(void)";
    string n = 0;
    if(function_exists("query_name", ob)) n = (string)ob->query_name();
    if(!n || n == "") n = basename_path(file_name(ob));
    return n;
}

string obj_short(object ob) {
    if(!objectp(ob)) return "nothing";
    if(function_exists("query_short", ob)) {
        string s = (string)ob->query_short();
        if(s && s != "") return s;
    }
    return capitalize(obj_name(ob));
}

object find_ob(string str, object env) {
    object *inv; int i;
    if(!objectp(env) || !stringp(str) || str == "") return 0;
    inv = all_inventory(env);
    for(i = 0; i < sizeof(inv); i++) {
        if(inv[i] && function_exists("id", inv[i]) && inv[i]->id(str))
            return inv[i];
    }
    return 0;
}

object find_living_here(string name, object env) {
    object *inv; int i;
    if(!objectp(env) || !stringp(name)) return 0;
    inv = all_inventory(env);
    for(i = 0; i < sizeof(inv); i++) {
        if(inv[i] && living(inv[i]) && function_exists("query_name", inv[i])) {
            if(lower_case((string)inv[i]->query_name()) == lower_case(name))
                return inv[i];
        }
    }
    return 0;
}

// ============================================================
// INTRODUCTION-SYSTEM-AWARE NAME LOOKUP
// Returns what `viewer` sees when looking at `ob`.
// Falls back to race/article for unintroduced players.
// ============================================================

string vis_name(object ob, object viewer) {
    if(!objectp(ob)) return "someone";
    if(function_exists("query_introduction_name", ob)) {
        string n = (string)ob->query_introduction_name(viewer);
        if(n && n != "") return n;
    }
    return obj_name(ob);
}

// Sends msg to each living in room, replacing first %s with
// capitalize(vis_name(actor, that_viewer)).
// actor is excluded (they see "You ..." separately).

void tell_room_vis(object room, object actor, string format, object *exclude) {
    object *inv; int i;
    if(!objectp(room) || !stringp(format)) return;
    if(!arrayp(exclude)) exclude = ({});
    inv = all_inventory(room);
    for(i = 0; i < sizeof(inv); i++) {
        if(!inv[i] || !living(inv[i])) continue;
        if(member_array(inv[i], exclude) != -1) continue;
        string aname = capitalize(vis_name(actor, inv[i]));
        string msg = format;
        int idx = strsrch(msg, "%s");
        if(idx >= 0) msg = msg[0..idx-1] + aname + msg[idx+2..];
        tell_object(inv[i], msg);
    }
}

// ============================================================
// MESSAGING UTILITIES
// ============================================================

void tell_room(object room, string msg, object *exclude) {
    object *inv; int i;
    if(!objectp(room) || !stringp(msg)) return;
    if(!arrayp(exclude)) exclude = ({});
    inv = all_inventory(room);
    for(i = 0; i < sizeof(inv); i++) {
        if(inv[i] && living(inv[i]) && member_array(inv[i], exclude) == -1)
            tell_object(inv[i], msg);
    }
}

void shout_all(string msg) {
    object *us = users(); int i;
    if(!arrayp(us)) return;
    for(i = 0; i < sizeof(us); i++)
        if(us[i] && living(us[i])) tell_object(us[i], msg);
}

// ============================================================
// MATH / RANDOM
// ============================================================

int clamp(int val, int mn, int mx) {
    if(val < mn) return mn;
    if(val > mx) return mx;
    return val;
}

int random_range(int mn, int mx) {
    if(mx <= mn) return mn;
    return mn + random(mx - mn + 1);
}

// ============================================================
// TYPE COERCION
// ============================================================

string to_string(mixed v) {
    if(!v && v != 0) return "";
    if(stringp(v)) return v;
    if(intp(v)) return sprintf("%d", v);
    if(floatp(v)) return sprintf("%.4f", v);
    if(objectp(v)) return file_name(v);
    return "";
}

int to_int(mixed v) {
    if(intp(v)) return v;
    if(stringp(v) && v != "") return (int)v;
    if(floatp(v)) return (int)v;
    return 0;
}

// ============================================================
// TIME FORMATTING
// ============================================================

string format_duration(int seconds) {
    int h, m, s;
    if(seconds < 0) seconds = 0;
    h = seconds / 3600;
    m = (seconds % 3600) / 60;
    s = seconds % 60;
    if(h > 0) return sprintf("%dh %dm %ds", h, m, s);
    if(m > 0) return sprintf("%dm %ds", m, s);
    return sprintf("%ds", s);
}

// ============================================================
// CASE CONVERSION
// ============================================================

string lower_case(string str) {
    if(!str) return "";
    int i; string out = "";
    for(i = 0; i < strlen(str); i++) {
        int c = str[i];
        if(c >= 65 && c <= 90) out += sprintf("%c", c + 32);
        else out += sprintf("%c", c);
    }
    return out;
}

string upper_case(string str) {
    if(!str) return "";
    int i; string out = "";
    for(i = 0; i < strlen(str); i++) {
        int c = str[i];
        if(c >= 97 && c <= 122) out += sprintf("%c", c - 32);
        else out += sprintf("%c", c);
    }
    return out;
}

// ============================================================
// ARRAY UTILITIES
// ============================================================

int member_array(mixed item, mixed *arr) {
    int i;
    if(!arr) return -1;
    for(i = 0; i < sizeof(arr); i++)
        if(arr[i] == item) return i;
    return -1;
}

// ============================================================
// OBJECT TYPE CHECKS
// ============================================================

int is_player(object ob) {
    if(!ob) return 0;
    return ob->query_privilege_level() >= 0 && !ob->query_is_npc();
}

int is_npc(object ob) {
    if(!ob) return 0;
    return ob->query_is_npc();
}

// ============================================================
// SKILL HELPERS
// ============================================================

mixed query_skill_pct(object player, string skill_name) {
    if(!player || !skill_name) return 0;
    mapping skills = player->query_all_skills();
    if(!skills) return 0;
    if(member(skills, skill_name)) return skills[skill_name];
    return 0;
}
