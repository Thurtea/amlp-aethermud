// /lib/std/vehicle_room.lpc
// Base object for rooms inside vehicles
// Links back to parent vehicle

inherit "/lib/std/room";

private object parent_vehicle;         // The vehicle this room belongs to
private string vehicle_path;           // Path to vehicle (for persistence)
private string room_type;              // "cockpit", "cargo", "passenger", etc.
private int can_pilot_from_here;       // Can this room control the vehicle?

void create() {
    ::create();
    
    parent_vehicle = 0;
    vehicle_path = "";
    room_type = "passenger";
    can_pilot_from_here = 0;
    
    set_short("inside a vehicle");
    set_long("You are inside a vehicle. The walls vibrate with the hum of machinery.");
}

// === CONFIGURATION ===

void set_parent_vehicle(mixed vehicle) {
    if (objectp(vehicle)) {
        parent_vehicle = vehicle;
        vehicle_path = base_name(vehicle);
    } else if (stringp(vehicle)) {
        vehicle_path = vehicle;
        parent_vehicle = load_object(vehicle);
    }
}

object query_parent_vehicle() {
    if (!parent_vehicle && vehicle_path) {
        parent_vehicle = load_object(vehicle_path);
    }
    return parent_vehicle;
}

void set_room_type(string type) {
    room_type = type;
}

string query_room_type() {
    return room_type;
}

void set_can_pilot(int can) {
    can_pilot_from_here = can;
}

int query_can_pilot() {
    return can_pilot_from_here;
}

// === ROOM OVERRIDES ===

// Override exits to handle vehicle movement
string query_exit(string direction) {
    string exit;
    
    exit = ::query_exit(direction);
    
    // If no internal exit, this might be a vehicle movement command
    if (!exit && room_type == "cockpit") {
        return "VEHICLE_MOVE:" + direction;
    }
    
    return exit;
}

// === SPECIAL COMMANDS ===

void init() {
    ::init();
    
    // Add vehicle-specific commands
    add_action("do_vehicle_status", "vstatus");
    add_action("do_vehicle_status", "vehicle");
    
    if (room_type == "cockpit" || can_pilot_from_here) {
        add_action("do_pilot", "pilot");
        add_action("do_start_engine", "start");
        add_action("do_stop_engine", "stop");
    }
    
    add_action("do_exit_vehicle", "exit");
    add_action("do_exit_vehicle", "disembark");
}

int do_vehicle_status(string args) {
    object vehicle;
    
    vehicle = query_parent_vehicle();
    
    if (!vehicle) {
        write("Error: Cannot find parent vehicle.");
        return 1;
    }
    
    write(vehicle->query_vehicle_status());
    return 1;
}

int do_pilot(string args) {
    object vehicle, player;
    
    if (!can_pilot_from_here && room_type != "cockpit") {
        write("You cannot control the vehicle from here.");
        return 1;
    }
    
    vehicle = query_parent_vehicle();
    if (!vehicle) {
        write("Error: Cannot find parent vehicle.");
        return 1;
    }
    
    player = this_player();
    
    if (vehicle->query_pilot() == player) {
        write("You are already piloting this vehicle.");
        return 1;
    }
    
    if (vehicle->query_pilot()) {
        write("Someone else is already piloting this vehicle.");
        return 1;
    }
    
    if (!vehicle->can_pilot(player)) {
        write("You don't have the necessary skill to pilot this vehicle.");
        write("Required skill: " + vehicle->query_pilot_skill());
        return 1;
    }
    
    if (vehicle->set_pilot(player)) {
        write("You take control of the vehicle.");
        say(player->query_cap_name() + " takes control of the vehicle.");
        return 1;
    }
    
    write("You cannot pilot this vehicle right now.");
    return 1;
}

int do_start_engine(string args) {
    object vehicle, player;
    int result;
    
    vehicle = query_parent_vehicle();
    if (!vehicle) return 0;
    
    player = this_player();
    
    if (vehicle->query_pilot() != player) {
        write("You must be piloting the vehicle to start the engine.");
        return 1;
    }
    
    if (vehicle->query_engine_status()) {
        write("The engine is already running.");
        return 1;
    }
    
    result = vehicle->start_engine(player);
    
    if (result == 1) {
        write("You start the engine. The vehicle hums to life.");
        say(player->query_cap_name() + " starts the engine.");
        return 1;
    } else if (result == -1) {
        write("The engine sputters and dies. Out of fuel!");
        return 1;
    } else {
        write("You cannot start the engine.");
        return 1;
    }
}

int do_stop_engine(string args) {
    object vehicle, player;
    
    vehicle = query_parent_vehicle();
    if (!vehicle) return 0;
    
    player = this_player();
    
    if (vehicle->query_pilot() != player) {
        write("You must be piloting the vehicle to stop the engine.");
        return 1;
    }
    
    if (!vehicle->query_engine_status()) {
        write("The engine is already off.");
        return 1;
    }
    
    if (vehicle->stop_engine()) {
        write("You shut down the engine.");
        say(player->query_cap_name() + " shuts down the engine.");
        return 1;
    }
    
    write("You cannot stop the engine right now.");
    return 1;
}

int do_exit_vehicle(string args) {
    object vehicle, player, destination;
    
    vehicle = query_parent_vehicle();
    if (!vehicle) {
        write("Error: Cannot find parent vehicle.");
        return 1;
    }
    
    player = this_player();
    
    // Check if we're in the entry room or need to navigate there
    if (room_type != "entry" && room_type != "cockpit") {
        write("You need to make your way to the exit first.");
        return 1;
    }
    
    destination = environment(vehicle);
    if (!destination) {
        write("The vehicle is in a void. You cannot exit here.");
        return 1;
    }
    
    if (vehicle->exit_vehicle(player)) {
        write("You exit the vehicle.");
        say(player->query_cap_name() + " exits the vehicle.");
        
        // Message to the outside
        tell_room(destination, player->query_cap_name() + " emerges from " + 
                 vehicle->query_short() + ".");
        
        return 1;
    }
    
    write("You cannot exit the vehicle right now.");
    return 1;
}

// === MOVEMENT HANDLING ===

// When someone tries to move, check if it's vehicle movement
int prevent_leave(object player, string direction) {
    object vehicle;
    int result;
    
    // Let normal internal movement work
    if (::query_exit(direction)) {
        return 0; // Allow normal movement
    }
    
    // Check if this is vehicle movement
    if (room_type != "cockpit" && !can_pilot_from_here) {
        return 0; // Not a control room
    }
    
    vehicle = query_parent_vehicle();
    if (!vehicle) return 0;
    
    if (vehicle->query_pilot() != player) {
        return 0; // Not the pilot
    }
    
    if (!vehicle->query_engine_status()) {
        write("The engine isn't running. Start it first.");
        return 1; // Prevent movement
    }
    
    // Attempt vehicle movement
    result = vehicle->move_vehicle(direction);
    
    if (result == 1) {
        write("You pilot the vehicle " + direction + ".");
        say(player->query_cap_name() + " pilots the vehicle " + direction + ".");
        
        // Show new location to all passengers
        call_out("show_exterior", 1);
        return 1; // Movement handled
    } else if (result == -1) {
        write("The engine sputters and dies! Out of fuel!");
        return 1;
    } else if (result == -2) {
        write("You lose control momentarily but manage to keep the vehicle steady.");
        return 1;
    } else {
        write("You cannot move the vehicle in that direction.");
        return 1;
    }
}

void show_exterior() {
    object vehicle, exterior;
    string description;
    
    vehicle = query_parent_vehicle();
    if (!vehicle) return;
    
    exterior = environment(vehicle);
    if (!exterior) return;
    
    description = "Outside: " + exterior->query_short() + "\n";
    description += exterior->query_long();
    
    tell_room(this_object(), description);
}
