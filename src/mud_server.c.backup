#include "master_object.h"
#include "vm.h"
#include "efun.h"
#include "gc.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define MAX_CONNECTIONS 64
#define BUFFER_SIZE 1024
#define DEFAULT_PORT 3000

typedef struct {
    int socket;
    int active;
    char buffer[BUFFER_SIZE];
    void *connection_object;  // Current LPC object (login or user)
    void *input_callback;     // Function to call with next input (for input_to)
    char *callback_arg;       // Optional argument for callback
} PlayerConnection;

static int server_socket = -1;
static volatile int running = 1;
static PlayerConnection connections[MAX_CONNECTIONS];

static void signal_handler(int sig);
static void handle_new_connection(void);
static void handle_player_input(int slot);
static void cleanup_server(void);

int start_mud_server(int port) {
    printf("========================================\n");
    printf("  AMLP-MUD Server Starting\n");
    printf("========================================\n");
    printf("[Server] Port: %d\n", port);
    printf("[Server] Max connections: %d\n", MAX_CONNECTIONS);
    printf("\n");
    
    printf("[Server] Initializing virtual machine...\n");
    VirtualMachine *vm = vm_init();
    if (!vm) {
        fprintf(stderr, "[FATAL] Failed to initialize VM\n");
        return -1;
    }
    printf("[  OK  ] VM initialized\n");
    
    printf("[Server] Initializing efun registry...\n");
    EfunRegistry *efun_reg = efun_init();
    if (!efun_reg) {
        fprintf(stderr, "[FATAL] Failed to initialize efuns\n");
        return -1;
    }
    printf("[  OK  ] Efun registry initialized\n");
    
    printf("[Server] Initializing garbage collector...\n");
    GC *gc = gc_init();
    if (!gc) {
        fprintf(stderr, "[FATAL] Failed to initialize GC\n");
        return -1;
    }
    printf("[  OK  ] GC initialized\n\n");
    
    printf("[Server] Loading master object...\n");
    char *master_path = getenv("AMLP_MASTER");
    if (!master_path) {
        master_path = "./lib/secure/master.c";
    }
    
    printf("[Server] Master path: %s\n", master_path);
    int master_result = master_object_init(master_path, vm);
    
    if (master_result == 0) {
        printf("[  OK  ] Master object initialized\n");
    } else {
        fprintf(stderr, "[WARNING] Master object initialization incomplete\n");
        fprintf(stderr, "[WARNING] Server will continue with limited functionality\n");
    }
    
    printf("[Server] Registering driver callbacks...\n");
    if (master_register_callbacks() == 0) {
        printf("[  OK  ] Callbacks registered\n\n");
    } else {
        fprintf(stderr, "[ERROR] Failed to register callbacks\n");
        return -1;
    }
    
    printf("[Server] Creating server socket...\n");
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        perror("[FATAL] socket");
        return -1;
    }
    
    int opt = 1;
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("[WARNING] setsockopt");
    }
    
    struct sockaddr_in address;
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);
    
    if (bind(server_socket, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("[FATAL] bind");
        close(server_socket);
        return -1;
    }
    
    if (listen(server_socket, 5) < 0) {
        perror("[FATAL] listen");
        close(server_socket);
        return -1;
    }
    
    printf("[  OK  ] Socket bound to port %d\n", port);
    
    for (int i = 0; i < MAX_CONNECTIONS; i++) {
        connections[i].socket = -1;
        connections[i].active = 0;
        memset(connections[i].buffer, 0, BUFFER_SIZE);
    }
    
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    printf("\n========================================\n");
    printf("  Server Ready - Accepting Connections\n");
    printf("========================================\n");
    printf("Connect with: telnet localhost %d\n", port);
    printf("Stop server with: Ctrl+C\n\n");
    
    fd_set readfds;
    while (running) {
        FD_ZERO(&readfds);
        FD_SET(server_socket, &readfds);
        
        int max_fd = server_socket;
        for (int i = 0; i < MAX_CONNECTIONS; i++) {
            if (connections[i].active) {
                FD_SET(connections[i].socket, &readfds);
                if (connections[i].socket > max_fd) {
                    max_fd = connections[i].socket;
                }
            }
        }
        
        struct timeval tv;
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        
        int activity = select(max_fd + 1, &readfds, NULL, NULL, &tv);
        
        if (activity < 0 && errno != EINTR) {
            perror("[ERROR] select");
            break;
        }
        
        if (!running) break;
        
        if (FD_ISSET(server_socket, &readfds)) {
            handle_new_connection();
        }
        
        for (int i = 0; i < MAX_CONNECTIONS; i++) {
            if (connections[i].active && FD_ISSET(connections[i].socket, &readfds)) {
                handle_player_input(i);
            }
        }
    }
    
    cleanup_server();
    return 0;
}

static void signal_handler(int sig) {
    if (sig == SIGINT || sig == SIGTERM) {
        printf("\n[Server] Received shutdown signal, stopping...\n");
        running = 0;
    }
}

static void handle_new_connection(void) {
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);
    
    int new_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_len);
    if (new_socket < 0) {
        perror("[ERROR] accept");
        return;
    }
    
    int slot = -1;
    for (int i = 0; i < MAX_CONNECTIONS; i++) {
        if (!connections[i].active) {
            slot = i;
            break;
        }
    }
    
    if (slot < 0) {
        printf("[Server] Connection rejected - server full\n");
        const char *msg = "Server full - please try again later.\n";
        send(new_socket, msg, strlen(msg), 0);
        close(new_socket);
        return;
    }
    
    connections[slot].socket = new_socket;
    connections[slot].active = 1;
    memset(connections[slot].buffer, 0, BUFFER_SIZE);
    
    char *client_ip = inet_ntoa(client_addr.sin_addr);
    printf("[Server] Player connected from %s (slot %d)\n", client_ip, slot);
    
    const char *welcome = 
        "\n"
        "========================================\n"
        "       Welcome to AMLP-MUD\n"
        "========================================\n"
        "  A Multi-User Dungeon powered by\n"
        "  the AMLP-Driver LPC interpreter\n"
        "\n"
        "  Type 'help' for commands\n"
        "  Type 'quit' to disconnect\n"
        "========================================\n"
        "\n> ";
    
    send(new_socket, welcome, strlen(welcome), 0);
}

static void handle_player_input(int slot) {
    int bytes = recv(connections[slot].socket, connections[slot].buffer, 
                     BUFFER_SIZE - 1, 0);
    
    if (bytes <= 0) {
        close(connections[slot].socket);
        connections[slot].active = 0;
        printf("[Server] Player disconnected (slot %d)\n", slot);
        return;
    }
    
    connections[slot].buffer[bytes] = '\0';
    
    char *input = connections[slot].buffer;
    while (bytes > 0 && (input[bytes-1] == '\n' || input[bytes-1] == '\r')) {
        input[--bytes] = '\0';
    }
    
    if (bytes == 0) {
        send(connections[slot].socket, "> ", 2, 0);
        return;
    }
    
    printf("[Player %d] %s\n", slot, input);
    
    if (strcmp(input, "quit") == 0) {
        const char *goodbye = "Goodbye!\n";
        send(connections[slot].socket, goodbye, strlen(goodbye), 0);
        close(connections[slot].socket);
        connections[slot].active = 0;
        printf("[Server] Player quit (slot %d)\n", slot);
        return;
    }
    
    char response[BUFFER_SIZE];
    snprintf(response, sizeof(response), "Echo: %s\n> ", input);
    send(connections[slot].socket, response, strlen(response), 0);
}

static void cleanup_server(void) {
    printf("\n[Server] Shutting down...\n");
    
    for (int i = 0; i < MAX_CONNECTIONS; i++) {
        if (connections[i].active) {
            const char *msg = "\nServer shutting down...\n";
            send(connections[i].socket, msg, strlen(msg), 0);
            close(connections[i].socket);
            connections[i].active = 0;
        }
    }
    
    if (server_socket >= 0) {
        close(server_socket);
        server_socket = -1;
    }
    
    master_object_cleanup();
    printf("[Server] Shutdown complete\n");
}

int main(int argc, char **argv) {
    int port = DEFAULT_PORT;
    
    if (argc > 1) {
        port = atoi(argv[1]);
        if (port < 1024 || port > 65535) {
            fprintf(stderr, "Invalid port: %d (must be 1024-65535)\n", port);
            return 1;
        }
    }
    
    return start_mud_server(port);
}
